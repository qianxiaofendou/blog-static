<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack构建优化小记</title>
      <link href="/2018/10/26/webpack-optimize/"/>
      <url>/2018/10/26/webpack-optimize/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;webpack相信大家都不陌生了，在工作当中相信大家会经常用到，在处理资源构建打包的时候非常的有用，本文分享一下我在使用webpack进行项目构建的过程中总结的一些优化经验。</p><span id="more"></span><h3 id="模块的查找"><a href="#模块的查找" class="headerlink" title="模块的查找"></a>模块的查找</h3><p>当我们在项目中使用到第三方模块的时候，webpack在构建时，会先去当前目录下的 <code>./node_modules</code> 目录下去找想找的模块，如果没找到就去上一级目录 <code>../node_modules</code> 中找，再没有就去<code> ../../node_modules</code> 中找，以此类推，到这里，是不是觉得和nodejs里面模块的寻找机制很相似</p><p>当我们在安装第三方模块时，默认会安装在当前项目的根目录的 <code>./node_modules</code>文件夹里面，因此，为了提高webpack的查找速度，我们可以通过配置来指明第三方模块的存放路径，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line">    <span class="comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">&#x27;./node_modules&#x27;</span>)]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babel-loader的处理"><a href="#babel-loader的处理" class="headerlink" title="babel-loader的处理"></a>babel-loader的处理</h3><p>由于ES6、ES7、ES8的新语法特性的快速普及，现代浏览器(chrome、safari、firefox、edge等)大多都已支持，因此我们可以使用这些新的特性进行编程，但是由于市面上各大浏览器厂商更新迭代过快，导致浏览器版本过多，对于新语法特性的支持也参差不齐，因此我们需要使用<code>babel-loader</code>进行语法转换成ES5，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">query: &#123;</span><br><span class="line">                <span class="string">&#x27;presets&#x27;</span>: [<span class="string">&#x27;es2015&#x27;</span>, <span class="string">&#x27;stage-0&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="第三方模块构建处理"><a href="#第三方模块构建处理" class="headerlink" title="第三方模块构建处理"></a>第三方模块构建处理</h4><p>因为我们在文件里面可能会引入第三方模块来使用，第三方模块往往都是编译好的ES5的代码，并不需要loader再去处理，因此我们可以排除掉以提高loader的处理速度，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里也可使用正则，如：/node_modules/，webpack也可以识别</span></span><br><span class="line">exclude: path.resolve(__dirname , <span class="string">&#x27;./node_modules&#x27;</span>),</span><br></pre></td></tr></table></figure><h4 id="缓存的处理"><a href="#缓存的处理" class="headerlink" title="缓存的处理"></a>缓存的处理</h4><p>当我们的文件非常多的时候，构建的速度就会非常的慢了，babel-loader提供了一个<code>cacheDirectory</code>属性，这个属性默认是<code>false</code>不开启的，如果设置了这个参数并开启的话，被转换的结果将会被缓存起来，当webpack再次编译时，将会首先尝试从缓存中读取转换结果，以此避免资源浪费，使用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="ES-6-7-8-新的API的处理"><a href="#ES-6-7-8-新的API的处理" class="headerlink" title="ES(6|7|8)新的API的处理"></a>ES(6|7|8)新的API的处理</h4><p>由于Babel默认只转换新的javascript句法（syntax），对于新的API是不做处理的，比如Iterator、Generator、Set、Maps、Symbol、Promise等这些全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码，这样如果浏览器不支持这些新的api，那么它们将不会工作，同时页面也将会报错误异常。</p><p>针对这个问题，我们可以使用<code>bable-ployfill</code>来处理，这里有个新的问题，<code>babel-ployfill</code>文件巨大，它默认把所有的新的API进行了重写，污染了全局变量，因此并不适合我们，针对现代浏览器，我们需要有针对的对不支持的API进行按需处理，因此便有了<code>babel-plugin-transform-runtime</code>，使用它loader在处理的时候，会自动的为所需要的API进行自动添加，不会去污染全局API，使用的时候我们需要先提前安装好，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-transform-runtime babel-preset-env babel-preset-stage-2 -S</span><br></pre></td></tr></table></figure><p>在项目根目录新建<code>.babelrc</code>文件来进行配置，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;env&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;stage-2&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [ </span><br><span class="line">    [<span class="string">&quot;transform-runtime&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">&quot;helpers&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;polyfill&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;moduleName&quot;</span>: <span class="string">&quot;babel-runtime&quot;</span></span><br><span class="line">      &#125;]</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tree-shaking处理"><a href="#tree-shaking处理" class="headerlink" title="tree-shaking处理"></a>tree-shaking处理</h4><p>当我们在项目里面使用ES6的module语法(export和import)的时候，需要告知<code>babel-loader</code>不要将ES6的模块先转成CommonJS模块，使用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">            <span class="string">&#x27;presets&#x27;</span>: [</span><br><span class="line">                [<span class="string">&#x27;es2015&#x27;</span>, &#123;<span class="string">&#x27;modules&#x27;</span>: <span class="literal">false</span>&#125;], <span class="string">&#x27;stage-0&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以在项目根目录新建<code>.babelrc</code>文件来进行配置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;modules&quot;: false</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;stage-0&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ParallelUglifyPlugin"><a href="#使用-ParallelUglifyPlugin" class="headerlink" title="使用 ParallelUglifyPlugin"></a>使用 ParallelUglifyPlugin</h3><p>webpack默认提供了UglifyJS插件来压缩JS代码，但是它使用的是单线程压缩代码，也就是当我们有多个js需要压缩的时候，它需要一个个文件进行压缩。因此在构建的时候会非常慢(因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大)。</p><p>这个时候我们的<code>ParallelUglifyPlugin</code>就上场了，他会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行，这样我们的构建效率就可以更快了，使用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-parallel-uglify-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 使用 ParallelUglifyPlugin 开启多进程并行文件压缩</span></span><br><span class="line">    <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">      <span class="comment">// 可以看到，内部还是使用uglifyjs进行压缩，参数通uglifyjs</span></span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          <span class="comment">// 紧凑输出</span></span><br><span class="line">          beautify: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的注释</span></span><br><span class="line">          comments: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">          warnings: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">          drop_console: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">          collapse_vars: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">          reduce_vars: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过 new ParallelUglifyPlugin() 进行实例化时，支持以下参数：</p><ul><li>test：使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/，也就是默认压缩所有的 .js 文件。</li><li>include：使用正则去命中需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。</li><li>exclude：使用正则去命中不需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。</li><li>cacheDir：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。</li><li>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。</li><li>sourceMap：是否输出 Source Map，这会导致压缩过程变慢。</li><li>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</li><li>uglifyES：用于压缩 ES6 代码时的配置，Object 类型，直接透传给 UglifyES 的参数。</li></ul><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">  uglifyJS: &#123;&#125;,</span><br><span class="line">  test: <span class="regexp">/.js$/g</span>,</span><br><span class="line">  include: [],</span><br><span class="line">  exclude: [],</span><br><span class="line">  cacheDir: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  workerCount: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  sourceMap: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用-HappyPack"><a href="#使用-HappyPack" class="headerlink" title="使用 HappyPack"></a>使用 HappyPack</h3><p>happypack的工作原理是，告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程(和上面的<code>ParallelUglifyPlugin</code>类似)。</p><p>下面是一个相对比较全面的针对js、css、图片等的一个处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&#x27;happypack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;);</span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-parallel-uglify-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</span></span><br><span class="line">        use: [<span class="string">&#x27;happypack/loader?id=babel&#x27;</span>],</span><br><span class="line">        <span class="comment">// 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span></span><br><span class="line">        exclude: path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [<span class="string">&#x27;happypack/loader?id=css&#x27;</span>],</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 把对 图片类型 文件的处理转交给 id 为 image 的 HappyPack 实例</span></span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;happypack/loader?id=image&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span></span><br><span class="line">      id: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">      <span class="comment">// 如何处理 .js 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      loaders: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">      <span class="comment">// ... 其它配置项</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">&#x27;css&#x27;</span>,</span><br><span class="line">      <span class="comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      loaders: [<span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">      <span class="comment">// 如何处理 图片类型 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader : <span class="built_in">require</span>.resolve(<span class="string">&#x27;url-loader&#x27;</span>),</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit : <span class="number">10000</span>,</span><br><span class="line">          name: <span class="string">&#x27;static/images/[name].[ext]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],      </span><br><span class="line">      threadPool: happyThreadPool</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，我们的配置有了一些改变，我们把文件的处理交给了<code>happypack/loader</code>来处理了，并且在后面还有一个<code>id</code>的参数，参数的值表示我们在使用<code>happypack</code>插件去实例化的时候该选择哪一个实例去处理</p><p>在插件(plugins)配置里面，我们实例化了三个<code>happypack</code>的实例，每个实例对应的都有一个<code>id</code>，它的值就是我们上面在处理<code>loader</code>的时候所携带的参数的值是一样相对应的，如<code>?id=babel</code>，loaders的属性配置也和原来使用的loader的配置相同</p><p>同样的，<code>happypack</code>还支持其它一些参数，如下：</p><ul><li>threads 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数(如果你的CPU够强悍，可以多开启几个子进程，构建速度可以快的飞起)。</li><li>verbose 是否允许 HappyPack 输出日志，默认是 true。</li><li>threadPool 代表共享进程池，即多个 HappyPack实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多</li></ul><p>希望以上的一些构建性能优化的点，可以在大家使用webpack进行资源编译的时候能够有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用js判断元素是否可见</title>
      <link href="/2018/07/09/check-if-element-is-hidden/"/>
      <url>/2018/07/09/check-if-element-is-hidden/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在日常的开发里面，我们会经常遇到需要判断一个元素是否显示的情况，相信大家对于这样的情形已经司空见惯了，几乎可以随手拈来，不在话下，那么本文我们就来跟大家分享一下常用的一些在JavaScript中判断元素是否显示的几种方法。</p><span id="more"></span><p>首先我们先写个html结构，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们设置输入框为隐藏</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-tag">input</span> &#123;<span class="attribute">display</span>:none&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来看一下怎么判断我们的输入框现在是否可见呢</p><h3 id="第一种方法：通过获取元素display属性来实现"><a href="#第一种方法：通过获取元素display属性来实现" class="headerlink" title="第一种方法：通过获取元素display属性来实现"></a>第一种方法：通过获取元素display属性来实现</h3><p>在JavaScript中，我们可以通过对元素的display属性值做判断，只要判断是否为<code>none</code>即可；因为元素分为 块级、行内元素，且显示元素的display属性值有多种不确定性。 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHidden</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> style = <span class="built_in">window</span>.getComputedStyle(el);</span><br><span class="line">    <span class="keyword">return</span> (style.display === <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isHidden(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;userName&#x27;</span>)))  <span class="comment">// 输出为true</span></span><br></pre></td></tr></table></figure><p>可以看到，已经达到了我们想要的效果，这也是我们经常会用到的方法</p><h3 id="第二种方法：使用jQuery的-is-“-hidden”"><a href="#第二种方法：使用jQuery的-is-“-hidden”" class="headerlink" title="第二种方法：使用jQuery的.is(“:hidden”)"></a>第二种方法：使用jQuery的.is(“:hidden”)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isHidden = $(<span class="string">&#x27;#userName&#x27;</span>).is(<span class="string">&#x27;:hidden&#x27;</span>)</span><br><span class="line"><span class="comment">// 这里我们可以得到结果为true，说明元素是不可见的</span></span><br></pre></td></tr></table></figure><p>上面两种方法都是基于当前元素设置了<code>diaplay</code>为<code>none</code>的情况，那么如果我们当前元素也就是我们的输入框不做设置，而是把他的父级元素设置为<code>none</code>，这时候，再来判断我们的输入框是否可见，那么，第一种方法的验证就会失败，第二种基于jQuery的验证会正确的返回为<code>true</code>得到正确的结果，那么有没有不基于第三方库，而是使用原生的JavaScript来达到我们想要的效果呢，接下来，我们来看第三种方法：</p><h3 id="第三种方法-判断当前元素的父元素的offsetParent属性"><a href="#第三种方法-判断当前元素的父元素的offsetParent属性" class="headerlink" title="第三种方法: 判断当前元素的父元素的offsetParent属性"></a>第三种方法: 判断当前元素的父元素的offsetParent属性</h3><p>对于元素的<code>offsetParent</code>属性,<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent" title="MDN">MDN</a>的解释为：</p><blockquote><p><code> HTMLElement.offsetParent</code> 是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 <code>offsetParent</code> 为最近的<code>table</code>, <code>table cell</code> 或根元素（标准模式下为<code>html</code>；quirks 模式下为 <code>body</code>）。当元素的 style.display 设置为 “none” 时，<code>offsetParent</code> 返回 <code>null</code>。<code>offsetParent</code> 很有用，因为<code> offsetTop</code> 和 <code>offsetLeft</code> 都是相对于其内边距边界的。</p></blockquote><p>也就是说，该属性会去校验当前元素是否设置了<code>display</code>为<code>none</code>，如果没有，会依次向上查找最近的一层父级元素，直至到根元素，如果有元素设置了<code>none</code>的属性，则<code>offsetParent</code> 会返回 <code>null</code>，如下：</p><p>现在，我们设置输入框的父级元素为不可见<code>.wrapper &#123;display:none&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHidden</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (el.offsetParent === <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isHidden(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;userName&#x27;</span>)))  <span class="comment">// 输出为true</span></span><br><span class="line"><span class="built_in">console</span>.log(isHidden(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.wrapper&#x27;</span>)))   <span class="comment">// 输出为true</span></span><br></pre></td></tr></table></figure><p>当前元素和父元素都输出了我们预想中的结果，但是这种方法需要注意一个边界情况，如果当前元素也就是输入框不做任何设置，他的父元素设置为<code>.wrapper &#123;position:fixed;&#125;</code>,也就是设置了<code>position</code>属性为<code>fixed</code>，这时，<code>offsetParent</code>也会返回<code>null</code>，所以大家在使用的时候要稍加注意。</p><p>上面三种方法都完成了我们对于校验元素是否可见的功能，但是对于元素是否可见，我们除了可以设置元素的<code>display</code>属性为<code>none</code>的情况，我们还可以设置<code>visibility</code>为<code>hidden</code>，在这个时候，上面的三种方法都会失效，需要做单独判断，这一点，请大家知晓！</p><p>那么对于设置了<code>visibility</code>为<code>hidden</code>的时候，有网友给出了以下解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> style = <span class="built_in">window</span>.getComputedStyle(ele);</span><br><span class="line">    <span class="keyword">return</span>  style.width !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">            style.height !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">            style.opacity !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">            style.display!==<span class="string">&#x27;none&#x27;</span> &amp;&amp;</span><br><span class="line">            style.visibility!== <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true为显示，false为隐藏</span></span><br></pre></td></tr></table></figure><p>经测试，该方法对于当前元素以及父元素设置为<code>visibility</code>属性值为<code>hidden</code>的情况都可以返回正确的结果，但是对于<code>display</code>为<code>none</code>的情况无效，因此，对于判断元素是否可见，可使用上面的方法进行综合判断，希望本文可以帮助到大家！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 搭建ftp服务器</title>
      <link href="/2018/05/25/linux-ftp/"/>
      <url>/2018/05/25/linux-ftp/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;使用FTP跟服务器之间进行文件的上传与下载操作是很方便的，即使是一个小白也很容易上手，那么怎么在服务器上面来搭建这么一个FTP呢，本文就带着大家在服务器上面进行一次FTP的搭建操作。</p><span id="more"></span><h3 id="物料的准备"><a href="#物料的准备" class="headerlink" title="物料的准备"></a>物料的准备</h3><blockquote><p>CentOS 7 服务器一台<br>FileZilla –ftp客户端，链接ftp使用</p></blockquote><p>好了，现在我们登录自己的服务器，开始搭建我们的FTP</p><h3 id="安装FTP服务器–vsftpd"><a href="#安装FTP服务器–vsftpd" class="headerlink" title="安装FTP服务器–vsftpd"></a>安装FTP服务器–vsftpd</h3><p>1、检查服务器是否已安装了vsftpd</p><p>有些服务器默认已经安装了vsftpd，因此我们要先确认一下是否安装过，使用以下命令进行查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsftpd -v</span><br></pre></td></tr></table></figure><p>如果输出版本号，则证明已经安装，如若没有，进行第二步</p><p>2、安装vsftpd，使用<code>yum install vsftpd</code>命令即可，安装完成后需要手动启动它，并设置为开机启动(也可以在完成相关配置之后在启动)，相关命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# systemctl start vsftpd</span><br><span class="line">[root@localhost &#x2F;]# systemctl enable vsftpd</span><br></pre></td></tr></table></figure><p>3、由于ftp是默认监听的是21端口，因此我们需要在防火墙里面添加开放21端口，CentOS 7默认使用的是FireWall防火墙，因此我们需要配置该防火墙，开启ftp协议服务，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;21&#x2F;tcp</span><br><span class="line"># firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;ftp</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="配置ftp服务器"><a href="#配置ftp服务器" class="headerlink" title="配置ftp服务器"></a>配置ftp服务器</h3><p>1、备份vsftpd的配置文件，以备后面配置错误还原使用，vsftp默认安装在<code>/etc/</code>下面，使用如下命令进行文件备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cp &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf.bak</span><br></pre></td></tr></table></figure><p>2、对vsftpd的配置文件进行一些相关的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable&#x3D;NO             # 是否允许匿名登录FTP服务器，默认设置为YES允许,这里设置为NO，不允许匿名登录</span><br><span class="line">local_enable&#x3D;YES        # 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许</span><br><span class="line">write_enable&#x3D;YES        # 是否允许本地用户对FTP服务器文件具有写权限，默认设置为YES允许</span><br><span class="line">local_umask&#x3D;022            # 掩码，本地用户默认掩码为077</span><br><span class="line">dirmessage_enable&#x3D;YES        # 是否激活目录欢迎信息功能，当用户用CMD模式首次访问服务器上某个目录时，FTP服务器将显示欢迎信息，默认情况下，欢迎信息是通过该目录下的.message文件获得的，此文件保存自定义的欢迎信息，由用户自己建立</span><br><span class="line">xferlog_enable&#x3D;YES        # 是否让系统自动维护上传和下载的日志文件，默认情况该日志文件为&#x2F;var&#x2F;log&#x2F;vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定</span><br><span class="line">connect_from_port_20&#x3D;YES        # 是否设定FTP服务器将启用FTP数据端口的连接请求 ftp-data数据传输，21为连接控制端口</span><br><span class="line">xferlog_std_format&#x3D;YES          # 是否以标准xferlog的格式书写传输日志文件 默认为&#x2F;var&#x2F;log&#x2F;xferlog，也可以通过xferlog_file选项对其进行设定</span><br><span class="line">listen&#x3D;NO           # 是否允许监听 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求</span><br><span class="line">listen_ipv6&#x3D;YES            # 设定是否支持IPV6。如要同时监听IPv4和IPv6端口，则必须运行两套vsftpd，采用两套配置文件 同时确保其中有一个监听选项是被注释掉的</span><br><span class="line">pam_service_name&#x3D;vsftpd         # 设置PAM外挂模块提供的认证服务所使用的配置文件名，即&#x2F;etc&#x2F;pam.d&#x2F;vsftpd文件</span><br><span class="line">userlist_enable&#x3D;YES          # 是否允许ftpusers文件中的用户登录FTP服务器，默认为NO，下面详细讲解</span><br><span class="line">tcp_wrappers&#x3D;YES          # 是否使用tcp_wrappers作为主机访问控制方式。</span><br></pre></td></tr></table></figure><p>相关配置的说明，详见对应配置后面的注释</p><p>3、开启用户对ftp的访问</p><p>在vsftpd目录下面，有个<code>vsftpd.userlist</code>的文件，这个文件存放可以登录ftp的用户</p><p>默认情况下，如果<code>userlist_enable=YES</code>，同时将<code>userlist_deny</code>选项设置为YES，那么意味着在<code>userlist_file=/etc/vsftpd/vsftpd.userlist</code>中列出的用户将拒绝登录访问ftp</p><p>但是， 使用<code>userlist_deny=NO</code>这个配置会更改对应的权限，这意味着只有在<code>userlist_file =/etc/vsftpd/vsftpd.userlist</code>中明确列出的用户才能被允许登录，因此我们进行以下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userlist_enable&#x3D;YES</span><br><span class="line">userlist_file&#x3D;&#x2F;etc&#x2F;vsfptd&#x2F;vsftpd.userlist</span><br><span class="line">userlist_deny&#x3D;NO</span><br></pre></td></tr></table></figure><p>ps:若是/etc/vsftpd下面没有vsftpd.userlist,则自己新建该文件即可</p><p>4、锁定用户的主目录<br>在用户登录之后，默认进入到自己的主目录，并且不允许切换到父级目录以外的目录，把用户锁定在自己的目录内，只能在自己的目录内活动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chroot_local_user&#x3D;YES</span><br><span class="line">allow_writeable_chroot&#x3D;YES</span><br></pre></td></tr></table></figure><p><code>chroot_local_user=YES</code>限制用户只能在自己的主目录下面活动，不允许跳出主目录之外</p><h3 id="开启ftp的保护功能"><a href="#开启ftp的保护功能" class="headerlink" title="开启ftp的保护功能"></a>开启ftp的保护功能</h3><p>1、开启SELinux，允许FTP读取用户主目录中的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># setsebool -P ftp_home_dir on</span><br></pre></td></tr></table></figure><p>如果提示错误，使用如下命令开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># semanage boolean -m ftpd_full_access --on</span><br></pre></td></tr></table></figure><p>这一步如果提示命令<code>semanage</code>不存在，在需要安装，<code>yum</code>的源里面默认是没有的，我们需要使用下面的命令来查找合适的安装源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# yum provides semanage</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.163.com</span><br><span class="line"> * extras: mirrors.huaweicloud.com</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line">base&#x2F;7&#x2F;x86_64&#x2F;filelists_db    | 6.9 MB  00:00:02</span><br><span class="line">extras&#x2F;7&#x2F;x86_64&#x2F;filelists_db  | 444 kB  00:00:01</span><br><span class="line">nginx&#x2F;x86_64&#x2F;filelists_db     |  44 kB  00:00:00</span><br><span class="line">updates&#x2F;7&#x2F;x86_64&#x2F;filelists_db | 637 kB  00:00:00</span><br><span class="line">policycoreutils-python-2.5-22.el7.x86_64 : SELinux policy core python utilities</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;sbin&#x2F;semanage</span><br></pre></td></tr></table></figure><p>可以看到我们查找到的文件版本，安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# yum -y install policycoreutils-python-2.5-22.el7.x86_64</span><br></pre></td></tr></table></figure><p>到目前为止，vsftp的相关配置已经完成，现在重启vsftpd服务(如果之前没有开启过，使用上面第一步里面的开启命令即可)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# systemctl restart vsftpd</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>1、创建一个用户，用来测试登录ftp使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# useradd -m -c &#39;ftp test&#39; -s &#x2F;bin&#x2F;bash xiaoming</span><br><span class="line">[root@localhost &#x2F;]# passwd xiaoming</span><br></pre></td></tr></table></figure><p>上面创建了一个用户xiaoming，该用户的登录shell是/bin/bash,-c 是用户描述</p><p>2、添加到vsftpd的用户列表文件</p><p>使用echo命令将用户xiaoming添加到文件/etc/vsftpd.userlist ，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# echo &#39;xiaoming&#39; | tee -a &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.userlist</span><br><span class="line">[root@localhost &#x2F;]# cat &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.userlist</span><br></pre></td></tr></table></figure><p>3、现在我们使用ftp登录验证一下(如果提示此命令不存在，使用<code>yum</code>安装即可)</p><p>先匿名用户测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# ftp 192.188.12.126</span><br><span class="line">Connected to 192.188.12.126 (192.188.12.126).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.188.12.126:root): anonymous</span><br><span class="line"></span><br><span class="line">530 Permission denied.</span><br><span class="line">Login failed.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure><p>由于我们在上面配置了禁止匿名用户登录ftp，所以可以看到使用匿名用户登录失败，不允许访问我们的ftp</p><p>2、使用我们刚添加的用户xiaoming测试登录ftp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# ftp 192.188.12.126</span><br><span class="line">Connected to 192.188.12.126 (192.188.12.126).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.188.12.126:root): xiaoming</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure><p>可以看到，用户xiaoming登录成</p><p>用户xiaoming在登录后，并没有自己的目录，那么接下来我们为xiaoming配置他的主目录</p><h3 id="配置ftp用户访问目录"><a href="#配置ftp用户访问目录" class="headerlink" title="配置ftp用户访问目录"></a>配置ftp用户访问目录</h3><p>1、创建目录(或者使用已有的目录进行分配也可以)，这里我们演示一下为用户xiaoming创建自己的ftp目录，并进行赋权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# mkdir &#x2F;home&#x2F;xiaoming&#x2F;ftp&#x2F;files</span><br><span class="line">[root@localhost &#x2F;]# chown ravi:ravi  &#x2F;home&#x2F;xiaoming&#x2F;ftp&#x2F;files</span><br><span class="line">[root@localhost &#x2F;]# chmod 0700 &#x2F;home&#x2F;xiaoming&#x2F;ftp&#x2F;files&#x2F;</span><br></pre></td></tr></table></figure><p>2、修改vsftpd的配置文件</p><p>然后在vsftpd配置文件中添加/修改以下选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_sub_token&#x3D;$USER         #在根目录插入用户名</span><br><span class="line">local_root&#x3D;&#x2F;var&#x2F;$USER&#x2F;ftp   #定义用户自己的目录</span><br></pre></td></tr></table></figure><p>由于修改了vsftpd的配置文件，因此需用重启vsftp服务</p><p>3、验证用户xiaoming登录ftp后的访问目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# ftp 192.188.12.126</span><br><span class="line">Connected to 192.188.12.126 (192.188.12.126).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.188.12.126:root): xiaoming</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">227 Entering Passive Mode (192,188,12,126,58,47).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxrwxrwx    2 0        0              32 May 25 14:06 files</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure><p>可以看到在用户xiaoming的ftp目录下面，有自己的主目录了，现在可以使用我们上面准备的ftp客户端(FileZilla)进行登录验证了</p><p>在使用中如果碰到<code>响应:    550 Failed to change directory.</code>的错误，可进行如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# chmod -R 777 &#x2F;var&#x2F;xiaoming&#x2F;ftp&#x2F;files</span><br></pre></td></tr></table></figure><p>以上就是本教程的全部内容，相信通过本教程，对服务器搭建ftp能得到一些解惑，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最全的vim快捷键(转)</title>
      <link href="/2018/05/17/linux-vim/"/>
      <url>/2018/05/17/linux-vim/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;曾经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。</p><h3 id="1-关于Vim"><a href="#1-关于Vim" class="headerlink" title="1. 关于Vim"></a>1. 关于Vim</h3><p>vim是我最喜欢的编辑器，也是linux下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）</p><span id="more"></span><h4 id="1-1-Vim的几种模式"><a href="#1-1-Vim的几种模式" class="headerlink" title="1.1 Vim的几种模式"></a>1.1 Vim的几种模式</h4><p>正常模式：可以使用快捷键命令，或按:输入命令行。<br>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。<br>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。<br>替换模式：正常模式下，按R进入。</p><h3 id="2-启动Vim"><a href="#2-启动Vim" class="headerlink" title="2. 启动Vim"></a>2. 启动Vim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim -c cmd file: 在打开文件前，先执行指定的命令；</span><br><span class="line">vim -r file: 恢复上次异常退出的文件；</span><br><span class="line">vim -R file: 以只读的方式打开文件，但可以强制保存；</span><br><span class="line">vim -M file: 以只读的方式打开文件，不可以强制保存；</span><br><span class="line">vim -y num file: 将编辑窗口的大小设为num行；</span><br><span class="line">vim + file: 从文件的末尾开始；</span><br><span class="line">vim +num file: 从第num行开始；</span><br><span class="line">vim +&#x2F;string file: 打开file，并将光标停留在第一个找到的string上。</span><br><span class="line">vim --remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim --remote file在已有的gvim中打开文件。</span><br></pre></td></tr></table></figure><h3 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a>3. 文档操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">:e file --关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</span><br><span class="line">:e! file --放弃对当前文件的修改，编辑新的文件。</span><br><span class="line">:e+file -- 开始新的文件，并从文件尾开始编辑。</span><br><span class="line">:e+n file -- 开始新的文件，并从第n行开始编辑。</span><br><span class="line">:enew --编译一个未命名的新文档。(CTRL-W n)</span><br><span class="line">:e -- 重新加载当前文档。</span><br><span class="line">:e! -- 重新加载当前文档，并丢弃已做的改动。</span><br><span class="line">:e#或ctrl+^ -- 回到刚才编辑的文件，很实用。</span><br><span class="line">:f或ctrl+g -- 显示文档名，是否修改，和光标位置。</span><br><span class="line">:f filename -- 改变编辑的文件名，这时再保存相当于另存为。</span><br><span class="line">gf -- 打开以光标所在字符串为文件名的文件。</span><br><span class="line">:w -- 保存修改。</span><br><span class="line">:n1,n2w filename -- 选择性保存从某n1行到另n2行的内容。</span><br><span class="line">:wq -- 保存并退出。</span><br><span class="line">ZZ -- 保存并退出。</span><br><span class="line">:x -- 保存并退出。</span><br><span class="line">:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</span><br><span class="line">:saveas newfilename -- 另存为</span><br><span class="line">:browse e -- 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：</span><br><span class="line">:set browsedir&#x3D;last -- 用上次访问过的目录（默认）；</span><br><span class="line">:set browsedir&#x3D;buffer -- 用当前文件所在目录；</span><br><span class="line">:set browsedir&#x3D;current -- 用当前工作目录；</span><br><span class="line">:Sex -- 水平分割一个窗口，浏览文件系统；</span><br><span class="line">:Vex -- 垂直分割一个窗口，浏览文件系统；</span><br></pre></td></tr></table></figure><h3 id="4-光标的移动"><a href="#4-光标的移动" class="headerlink" title="4. 光标的移动"></a>4. 光标的移动</h3><h4 id="4-1-基本移动"><a href="#4-1-基本移动" class="headerlink" title="4.1 基本移动"></a>4.1 基本移动</h4><p>以下移动都是在normal模式下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">h或退格: 左移一个字符；</span><br><span class="line">l或空格: 右移一个字符；</span><br><span class="line">j: 下移一行；</span><br><span class="line">k: 上移一行；</span><br><span class="line">gj: 移动到一段内的下一行；</span><br><span class="line">gk: 移动到一段内的上一行；</span><br><span class="line">+或Enter: 把光标移至下一行第一个非空白字符。</span><br><span class="line">-: 把光标移至上一行第一个非空白字符。</span><br><span class="line">w: 前移一个单词，光标停在下一个单词开头；</span><br><span class="line">W: 移动下一个单词开头，但忽略一些标点；</span><br><span class="line">e: 前移一个单词，光标停在下一个单词末尾；</span><br><span class="line">E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</span><br><span class="line">b: 后移一个单词，光标停在上一个单词开头；</span><br><span class="line">B: 移动到上一个单词开头，忽略一些标点；</span><br><span class="line">ge: 后移一个单词，光标停在上一个单词末尾；</span><br><span class="line">gE: 同 ge ，不过‘单词’包含单词相邻的标点。</span><br><span class="line">(: 前移1句。</span><br><span class="line">): 后移1句。</span><br><span class="line">&#123;: 前移1段。</span><br><span class="line">&#125;: 后移1段。</span><br><span class="line">fc: 把光标移到同一行的下一个c字符处</span><br><span class="line">Fc: 把光标移到同一行的上一个c字符处</span><br><span class="line">tc: 把光标移到同一行的下一个c字符前</span><br><span class="line">Tc: 把光标移到同一行的上一个c字符后</span><br><span class="line">;: 配合f &amp; t使用，重复一次</span><br><span class="line">,: 配合f &amp; t使用，反向重复一次</span><br><span class="line"></span><br><span class="line">上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</span><br><span class="line"></span><br><span class="line">0: 移动到行首。</span><br><span class="line">g0: 移到光标所在屏幕行行首。</span><br><span class="line">^: 移动到本行第一个非空白字符。</span><br><span class="line">g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</span><br><span class="line">$: 移动到行尾。</span><br><span class="line">g$: 移动光标所在屏幕行行尾。</span><br><span class="line">n|: 把光标移到递n列上。</span><br><span class="line">nG: 到文件第n行。</span><br><span class="line">:n&lt;cr&gt; 移动到第n行。</span><br><span class="line">:$&lt;cr&gt; 移动到最后一行。</span><br><span class="line">H: 把光标移到屏幕最顶端一行。</span><br><span class="line">M: 把光标移到屏幕中间一行。</span><br><span class="line">L: 把光标移到屏幕最底端一行。</span><br><span class="line">gg: 到文件头部。</span><br><span class="line">G: 到文件尾部。</span><br></pre></td></tr></table></figure><h4 id="4-2-翻屏"><a href="#4-2-翻屏" class="headerlink" title="4.2 翻屏"></a>4.2 翻屏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f: 下翻一屏。</span><br><span class="line">ctrl+b: 上翻一屏。</span><br><span class="line">ctrl+d: 下翻半屏。</span><br><span class="line">ctrl+u: 上翻半屏。</span><br><span class="line">ctrl+e: 向下滚动一行。</span><br><span class="line">ctrl+y: 向上滚动一行。</span><br><span class="line">n%: 到文件n%的位置。</span><br><span class="line">zz: 将当前行移动到屏幕中央。</span><br><span class="line">zt: 将当前行移动到屏幕顶端。</span><br><span class="line">zb: 将当前行移动到屏幕底端。</span><br></pre></td></tr></table></figure><h4 id="4-3-标记"><a href="#4-3-标记" class="headerlink" title="4.3 标记"></a>4.3 标记</h4><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m&#123;a-z&#125;: 标记光标所在位置，局部标记，只用于当前文件。</span><br><span class="line">m&#123;A-Z&#125;: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</span><br><span class="line">&#96;&#123;a-z&#125;: 移动到标记位置。</span><br><span class="line">&#39;&#123;a-z&#125;: 移动到标记行的行首。</span><br><span class="line">&#96;&#123;0-9&#125;：回到上[2-10]次关闭vim时最后离开的位置。</span><br><span class="line">&#96;&#96;: 移动到上次编辑的位置。&#39;&#39;也可以，不过&#96;&#96;精确到列，而&#39;&#39;精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</span><br><span class="line">&#96;&quot;: 移动到上次离开的地方。</span><br><span class="line">&#96;.: 移动到最后改动的地方。</span><br><span class="line">:marks 显示所有标记。</span><br><span class="line">:delmarks a b -- 删除标记a和b。</span><br><span class="line">:delmarks a-c -- 删除标记a、b和c。</span><br><span class="line">:delmarks a c-f -- 删除标记a、c、d、e、f。</span><br><span class="line">:delmarks! -- 删除当前缓冲区的所有标记。</span><br><span class="line">:help mark-motions 查看更多关于mark的知识。</span><br></pre></td></tr></table></figure><h3 id="5-插入文本"><a href="#5-插入文本" class="headerlink" title="5. 插入文本"></a>5. 插入文本</h3><h4 id="5-1-基本插入"><a href="#5-1-基本插入" class="headerlink" title="5.1 基本插入"></a>5.1 基本插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入&#x3D;， 按esc进入命令模式，就会出现8个&#x3D;。 这在插入分割线时非常有用，如30i+&lt;esc&gt;就插入了36个+组成的分割线。</span><br><span class="line">I: 在当前行第一个非空字符前插入；</span><br><span class="line">gI: 在当前行第一列插入；</span><br><span class="line">a: 在光标后插入；</span><br><span class="line">A: 在当前行最后插入；</span><br><span class="line">o: 在下面新建一行插入；</span><br><span class="line">O: 在上面新建一行插入；</span><br><span class="line">:r filename在当前位置插入另一个文件的内容。</span><br><span class="line">:[n]r filename在第n行插入另一个文件的内容。</span><br><span class="line">:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</span><br></pre></td></tr></table></figure><h4 id="5-2-改写插入"><a href="#5-2-改写插入" class="headerlink" title="5.2 改写插入"></a>5.2 改写插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c[n]w: 改写光标后1(n)个词。</span><br><span class="line">c[n]l: 改写光标后n个字母。</span><br><span class="line">c[n]h: 改写光标前n个字母。</span><br><span class="line">[n]cc: 修改当前[n]行。</span><br><span class="line">[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</span><br><span class="line">[n]S: 删除指定数目的行，并以所输入文本代替之。</span><br></pre></td></tr></table></figure><p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p><h3 id="6-剪切复制和寄存器"><a href="#6-剪切复制和寄存器" class="headerlink" title="6. 剪切复制和寄存器"></a>6. 剪切复制和寄存器</h3><h4 id="6-1-剪切和复制、粘贴"><a href="#6-1-剪切和复制、粘贴" class="headerlink" title="6.1 剪切和复制、粘贴"></a>6.1 剪切和复制、粘贴</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[n]x: 剪切光标右边n个字符，相当于d[n]l。</span><br><span class="line">[n]X: 剪切光标左边n个字符，相当于d[n]h。</span><br><span class="line">y: 复制在可视模式下选中的文本。</span><br><span class="line">yy or Y: 复制整行文本。</span><br><span class="line">y[n]w: 复制一(n)个词。</span><br><span class="line">y[n]l: 复制光标右边1(n)个字符。</span><br><span class="line">y[n]h: 复制光标左边1(n)个字符。</span><br><span class="line">y$: 从光标当前位置复制到行尾。</span><br><span class="line">y0: 从光标当前位置复制到行首。</span><br><span class="line">:m,ny&lt;cr&gt; 复制m行到n行的内容。</span><br><span class="line">y1G或ygg: 复制光标以上的所有行。</span><br><span class="line">yG: 复制光标以下的所有行。</span><br><span class="line">yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</span><br><span class="line">d: 删除（剪切）在可视模式下选中的文本。</span><br><span class="line">d$ or D: 删除（剪切）当前位置到行尾的内容。</span><br><span class="line">d[n]w: 删除（剪切）1(n)个单词</span><br><span class="line">d[n]l: 删除（剪切）光标右边1(n)个字符。</span><br><span class="line">d[n]h: 删除（剪切）光标左边1(n)个字符。</span><br><span class="line">d0: 删除（剪切）当前位置到行首的内容</span><br><span class="line">[n] dd: 删除（剪切）1(n)行。</span><br><span class="line">:m,nd&lt;cr&gt; 剪切m行到n行的内容。</span><br><span class="line">d1G或dgg: 剪切光标以上的所有行。</span><br><span class="line">dG: 剪切光标以下的所有行。</span><br><span class="line">daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</span><br><span class="line">d&#x2F;f&lt;cr&gt;：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</span><br><span class="line">p: 在光标之后粘贴。</span><br><span class="line">P: 在光标之前粘贴。</span><br></pre></td></tr></table></figure><h4 id="6-2-文本对象"><a href="#6-2-文本对象" class="headerlink" title="6.2 文本对象"></a>6.2 文本对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aw：一个词</span><br><span class="line">as：一句。</span><br><span class="line">ap：一段。</span><br><span class="line">ab：一块（包含在圆括号中的）。</span><br><span class="line">y, d, c, v都可以跟文本对象。</span><br></pre></td></tr></table></figure><h4 id="6-3-寄存器"><a href="#6-3-寄存器" class="headerlink" title="6.3 寄存器"></a>6.3 寄存器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a-z：都可以用作寄存器名。&quot;ayy把当前行的内容放入a寄存器。</span><br><span class="line">A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如&quot;Ayy把当前行的内容追加到a寄存器中。</span><br><span class="line">:reg 显示所有寄存器的内容。</span><br><span class="line">&quot;&quot;：不加寄存器索引时，默认使用的寄存器。</span><br><span class="line">&quot;*：当前选择缓冲区，&quot;*yy把当前行的内容放入当前选择缓冲区。</span><br><span class="line">&quot;+：系统剪贴板。&quot;+yy把当前行的内容放入系统剪贴板。</span><br></pre></td></tr></table></figure><h3 id="7-查找与替换"><a href="#7-查找与替换" class="headerlink" title="7. 查找与替换"></a>7. 查找与替换</h3><h4 id="7-1-查找"><a href="#7-1-查找" class="headerlink" title="7.1 查找"></a>7.1 查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;something: 在后面的文本中查找something。</span><br><span class="line">?something: 在前面的文本中查找something。</span><br><span class="line">&#x2F;pattern&#x2F;+number: 将光标停在包含pattern的行后面第number行上。</span><br><span class="line">&#x2F;pattern&#x2F;-number: 将光标停在包含pattern的行前面第number行上。</span><br><span class="line">n: 向后查找下一个。</span><br><span class="line">N: 向前查找下一个。</span><br></pre></td></tr></table></figure><p>可以用<code>grep</code>或<code>vimgrep</code>查找一个模式都在哪些地方出现过，<br>其中<code>:grep</code>是调用外部的grep程序，而<code>:vimgrep</code>是vim自己的查找算法。<br>用法为： <code>:vim[grep]/pattern/[g] [j] files</code><br>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。<br>j的含义是grep结束后，结果停在第j项，默认是停在第一项。<br>vimgrep前面可以加数字限定搜索结果的上限，如<br><code>:1vim/pattern/ %</code> 只查找那个模式在本文件中的第一个出现。</p><p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。<br>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：<code>:vim/^d&#123;1,&#125;./ %</code><br>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，<br>就更像个目录了。</p><h4 id="7-2-替换"><a href="#7-2-替换" class="headerlink" title="7.2 替换"></a>7.2 替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:s&#x2F;old&#x2F;new - 用new替换当前行第一个old。</span><br><span class="line">:s&#x2F;old&#x2F;new&#x2F;g - 用new替换当前行所有的old。</span><br><span class="line">:n1,n2s&#x2F;old&#x2F;new&#x2F;g - 用new替换文件n1行到n2行所有的old。</span><br><span class="line">:%s&#x2F;old&#x2F;new&#x2F;g - 用new替换文件中所有的old。</span><br><span class="line">:%s&#x2F;^&#x2F;xxx&#x2F;g - 在每一行的行首插入xxx，^表示行首。</span><br><span class="line">:%s&#x2F;$&#x2F;xxx&#x2F;g - 在每一行的行尾插入xxx，$表示行尾。</span><br></pre></td></tr></table></figure><p>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：<code>%s/old/new/gc</code>，加上i则忽略大小写(ignore)。<br>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，<br>语法为 :<code>[range]g/pattern/command</code><br>例如 :<code>%g/^ xyz/normal dd</code>。<br>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。<br>关于range的规定为：</p><p>如果不指定range，则表示当前行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m,n: 从m行到n行。</span><br><span class="line">0: 最开始一行（可能是这样）。</span><br><span class="line">$: 最后一行</span><br><span class="line">.: 当前行</span><br><span class="line">%: 所有行</span><br></pre></td></tr></table></figure><h4 id="7-3-正则表达式"><a href="#7-3-正则表达式" class="headerlink" title="7.3 正则表达式"></a>7.3 正则表达式</h4><p>高级的查找替换就要用到正则表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\d: 表示十进制数（我猜的）</span><br><span class="line">\s: 表示空格</span><br><span class="line">\S: 非空字符</span><br><span class="line">\a: 英文字母</span><br><span class="line">\|: 表示 或</span><br><span class="line">\.: 表示.</span><br><span class="line">&#123;m,n&#125;: 表示m到n个字符。这要和 \s与\a等连用，如 \a\&#123;m,n&#125; 表示m 到n个英文字母。</span><br><span class="line">&#123;m,&#125;: 表示m到无限多个字符。</span><br><span class="line">**: 当前目录下的所有子目录。</span><br><span class="line">:help pattern得到更多帮助。</span><br></pre></td></tr></table></figure><h3 id="8-排版"><a href="#8-排版" class="headerlink" title="8. 排版"></a>8. 排版</h3><h4 id="8-1-基本排版"><a href="#8-1-基本排版" class="headerlink" title="8.1 基本排版"></a>8.1 基本排版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt; 向左缩进一个shiftwidth</span><br><span class="line">&gt;&gt; 向右缩进一个shiftwidth</span><br><span class="line">:ce(nter) 本行文字居中</span><br><span class="line">:le(ft) 本行文字靠左</span><br><span class="line">:ri(ght) 本行文字靠右</span><br><span class="line">gq 对选中的文字重排，即对过长的文字进行断行</span><br><span class="line">gqq 重排当前行</span><br><span class="line">gqnq 重排n行</span><br><span class="line">gqap 重排当前段</span><br><span class="line">gqnap 重排n段</span><br><span class="line">gqnj 重排当前行和下面n行</span><br><span class="line">gqQ 重排当前段对文章末尾</span><br><span class="line">J 拼接当前行和下一行</span><br><span class="line">gJ 同 J ，不过合并后不留空格。</span><br><span class="line">#### 8.2 拼写检查</span><br><span class="line">:set spell－开启拼写检查功能</span><br><span class="line">:set nospell－关闭拼写检查功能</span><br><span class="line">]s－移到下一个拼写错误的单词</span><br><span class="line">[s－作用与上一命令类似，但它是从相反方向进行搜索</span><br><span class="line">z&#x3D;－显示一个有关拼写错误单词的列表，可从中选择</span><br><span class="line">zg－告诉拼写检查器该单词是拼写正确的</span><br><span class="line">zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</span><br></pre></td></tr></table></figure><h4 id="8-3-统计字数"><a href="#8-3-统计字数" class="headerlink" title="8.3 统计字数"></a>8.3 统计字数</h4><p><code>g ^g</code>可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p><h3 id="9-编辑多个文件"><a href="#9-编辑多个文件" class="headerlink" title="9. 编辑多个文件"></a>9. 编辑多个文件</h3><h4 id="9-1-一次编辑多个文件"><a href="#9-1-一次编辑多个文件" class="headerlink" title="9.1 一次编辑多个文件"></a>9.1 一次编辑多个文件</h4><p>我们可以一次打开多个文件，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> vi a.txt b.txt c.txt</span><br><span class="line">使用:next(:n)编辑下一个文件。</span><br><span class="line">:2n 编辑下2个文件。</span><br><span class="line">使用:previous或:N编辑上一个文件。</span><br><span class="line">使用:wnext，保存当前文件，并编辑下一个文件。</span><br><span class="line">使用:wprevious，保存当前文件，并编辑上一个文件。</span><br><span class="line">使用:args 显示文件列表。</span><br><span class="line">:n filenames或:args filenames 指定新的文件列表。</span><br><span class="line">vi -o filenames 在水平分割的多个窗口中编辑多个文件。</span><br><span class="line">vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</span><br></pre></td></tr></table></figure><h4 id="9-2-多标签编辑"><a href="#9-2-多标签编辑" class="headerlink" title="9.2 多标签编辑"></a>9.2 多标签编辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim -p files: 打开多个文件，每个文件占用一个标签页。</span><br><span class="line">:tabe, tabnew -- 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</span><br><span class="line">^w gf -- 在新的标签页里打开光标下路径指定的文件。</span><br><span class="line">:tabn -- 切换到下一个标签。Control + PageDown，也可以。</span><br><span class="line">:tabp -- 切换到上一个标签。Control + PageUp，也可以。</span><br><span class="line">[n] gt -- 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</span><br><span class="line">:tab split -- 将当前缓冲区的内容在新页签中打开。</span><br><span class="line">:tabc[lose] -- 关闭当前的标签页。</span><br><span class="line">:tabo[nly] -- 关闭其它的标签页。</span><br><span class="line">:tabs -- 列出所有的标签页和它们包含的窗口。</span><br><span class="line">:tabm[ove] [N] -- 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</span><br></pre></td></tr></table></figure><h4 id="9-3-缓冲区"><a href="#9-3-缓冲区" class="headerlink" title="9.3 缓冲区"></a>9.3 缓冲区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:buffers或:ls或:files 显示缓冲区列表。</span><br><span class="line">ctrl+^：在最近两个缓冲区间切换。</span><br><span class="line">:bn -- 下一个缓冲区。</span><br><span class="line">:bp -- 上一个缓冲区。</span><br><span class="line">:bl -- 最后一个缓冲区。</span><br><span class="line">:b[n]或:[n]b -- 切换到第n个缓冲区。</span><br><span class="line">:nbw(ipeout) -- 彻底删除第n个缓冲区。</span><br><span class="line">:nbd(elete) -- 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</span><br><span class="line">:ba[ll] -- 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</span><br></pre></td></tr></table></figure><h3 id="10-分屏编辑"><a href="#10-分屏编辑" class="headerlink" title="10. 分屏编辑"></a>10. 分屏编辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -o file1 file2:水平分割窗口，同时打开file1和file2</span><br><span class="line">vim -O file1 file2:垂直分割窗口，同时打开file1和file2</span><br></pre></td></tr></table></figure><h4 id="10-1-水平分割"><a href="#10-1-水平分割" class="headerlink" title="10.1 水平分割"></a>10.1 水平分割</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:split(:sp) -- 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</span><br><span class="line">:split filename -- 水平分割窗口，并在新窗口中显示另一个文件。</span><br><span class="line">:nsplit(:nsp) -- 水平分割出一个n行高的窗口。</span><br><span class="line">:[N]new -- 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</span><br><span class="line">ctrl+w f --水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</span><br><span class="line">C-w C-^ -- 水平分割一个窗口，打开刚才编辑的文件。</span><br></pre></td></tr></table></figure><h4 id="10-2-垂直分割"><a href="#10-2-垂直分割" class="headerlink" title="10.2 垂直分割"></a>10.2 垂直分割</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:vsplit(:vsp) -- 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</span><br><span class="line">:[N]vne[w] -- 垂直分割出一个新窗口。</span><br><span class="line">:vertical 水平分割的命令： 相应的垂直分割。</span><br></pre></td></tr></table></figure><h4 id="10-3-关闭子窗口"><a href="#10-3-关闭子窗口" class="headerlink" title="10.3 关闭子窗口"></a>10.3 关闭子窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:qall -- 关闭所有窗口，退出vim。</span><br><span class="line">:wall -- 保存所有修改过的窗口。</span><br><span class="line">:only -- 只保留当前窗口，关闭其它窗口。(CTRL-W o)</span><br><span class="line">:close -- 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</span><br></pre></td></tr></table></figure><h4 id="10-4-调整窗口大小"><a href="#10-4-调整窗口大小" class="headerlink" title="10.4 调整窗口大小"></a>10.4 调整窗口大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w + --当前窗口增高一行。也可以用n增高n行。</span><br><span class="line">ctrl+w - --当前窗口减小一行。也可以用n减小n行。</span><br><span class="line">ctrl+w _ --当前窗口扩展到尽可能的大。也可以用n设定行数。</span><br><span class="line">:resize n -- 当前窗口n行高。</span><br><span class="line">ctrl+w &#x3D; -- 所有窗口同样高度。</span><br><span class="line">n ctrl+w _ -- 当前窗口的高度设定为n行。</span><br><span class="line">ctrl+w &lt; --当前窗口减少一列。也可以用n减少n列。</span><br><span class="line">ctrl+w &gt; --当前窗口增宽一列。也可以用n增宽n列。</span><br><span class="line">ctrl+w | --当前窗口尽可能的宽。也可以用n设定列数。</span><br></pre></td></tr></table></figure><h4 id="10-5-切换和移动窗口"><a href="#10-5-切换和移动窗口" class="headerlink" title="10.5 切换和移动窗口"></a>10.5 切换和移动窗口</h4><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</span><br><span class="line">ctrl+w p: 切换到前一个窗口。</span><br><span class="line">ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</span><br><span class="line">ctrl+w t(b):切换到最上（下）面的窗口。&lt;BR&gt;</span><br><span class="line">ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</span><br><span class="line">ctrl+w r：旋转窗口的位置。</span><br><span class="line">ctrl+w T: 将当前的窗口移动到新的标签页上。</span><br></pre></td></tr></table></figure><h3 id="11-快速编辑"><a href="#11-快速编辑" class="headerlink" title="11. 快速编辑"></a>11. 快速编辑</h3><h4 id="11-1-改变大小写"><a href="#11-1-改变大小写" class="headerlink" title="11.1 改变大小写"></a>11.1 改变大小写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~: 反转光标所在字符的大小写。</span><br><span class="line">可视模式下的U或u：把选中的文本变为大写或小写。</span><br><span class="line">gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</span><br></pre></td></tr></table></figure><h4 id="11-2-替换（normal模式）"><a href="#11-2-替换（normal模式）" class="headerlink" title="11.2 替换（normal模式）"></a>11.2 替换（normal模式）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r: 替换光标处的字符，同样支持汉字。</span><br><span class="line">R: 进入替换模式，按esc回到正常模式。</span><br></pre></td></tr></table></figure><h4 id="11-3-撤消与重做（normal模式）"><a href="#11-3-撤消与重做（normal模式）" class="headerlink" title="11.3 撤消与重做（normal模式）"></a>11.3 撤消与重做（normal模式）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[n] u: 取消一(n)个改动。</span><br><span class="line">:undo 5 -- 撤销5个改变。</span><br><span class="line">:undolist -- 你的撤销历史。</span><br><span class="line">ctrl + r: 重做最后的改动。</span><br><span class="line">U: 取消当前行中所有的改动。</span><br><span class="line">:earlier 4m -- 回到4分钟前</span><br><span class="line">:later 55s -- 前进55秒</span><br></pre></td></tr></table></figure><h4 id="11-4-宏"><a href="#11-4-宏" class="headerlink" title="11.4 宏"></a>11.4 宏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. --重复上一个编辑动作</span><br><span class="line">qa：开始录制宏a（键盘操作记录）</span><br><span class="line">q：停止录制</span><br><span class="line">@a：播放宏a</span><br></pre></td></tr></table></figure><h3 id="12-编辑特殊文件"><a href="#12-编辑特殊文件" class="headerlink" title="12. 编辑特殊文件"></a>12. 编辑特殊文件</h3><h4 id="12-1-文件加解密"><a href="#12-1-文件加解密" class="headerlink" title="12.1 文件加解密"></a>12.1 文件加解密</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim -x file: 开始编辑一个加密的文件。</span><br><span class="line">:X -- 为当前文件设置密码。</span><br><span class="line">:set key&#x3D; -- 去除文件的密码。</span><br></pre></td></tr></table></figure><h4 id="12-2-文件的编码"><a href="#12-2-文件的编码" class="headerlink" title="12.2 文件的编码"></a>12.2 文件的编码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:e ++enc&#x3D;utf8 filename, 让vim用utf-8的编码打开这个文件。</span><br><span class="line">:w ++enc&#x3D;gbk，不管当前文件什么编码，把它转存成gbk编码。</span><br><span class="line">:set fenc或:set fileencoding，查看当前文件的编码。</span><br></pre></td></tr></table></figure><p>在vimrc中添加<code>set fileencoding=ucs-bom,utf-8,cp936</code>，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</p><p>让vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置</p><h4 id="12-3-文件格式"><a href="#12-3-文件格式" class="headerlink" title="12.3 文件格式"></a>12.3 文件格式</h4><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:e ++ff&#x3D;dos filename, 让vim用dos格式打开这个文件。</span><br><span class="line">:w ++ff&#x3D;mac filename, 以mac格式存储这个文件。</span><br><span class="line">:set ff，显示当前文件的格式。</span><br></pre></td></tr></table></figure><p>在vimrc中添加<code>set fileformats=unix,dos,mac</code>，让vim自动识别文件格式。</p><h3 id="13-编程辅助"><a href="#13-编程辅助" class="headerlink" title="13. 编程辅助"></a>13. 编程辅助</h3><h4 id="13-1-一些按键"><a href="#13-1-一些按键" class="headerlink" title="13.1 一些按键"></a>13.1 一些按键</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gd: 跳转到局部变量的定义处；</span><br><span class="line">gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</span><br><span class="line">g;: 上一个修改过的地方；</span><br><span class="line">g,: 下一个修改过的地方；</span><br><span class="line">[[: 跳转到上一个函数块开始，需要有单独一行的&#123;。</span><br><span class="line">]]: 跳转到下一个函数块开始，需要有单独一行的&#123;。</span><br><span class="line">[]: 跳转到上一个函数块结束，需要有单独一行的&#125;。</span><br><span class="line">][: 跳转到下一个函数块结束，需要有单独一行的&#125;。</span><br><span class="line">[&#123;: 跳转到当前块开始处；</span><br><span class="line">]&#125;: 跳转到当前块结束处；</span><br><span class="line">[&#x2F;: 跳转到当前注释块开始处；</span><br><span class="line">]&#x2F;: 跳转到当前注释块结束处；</span><br><span class="line">%: 不仅能移动到匹配的(),&#123;&#125;或[]上，而且能在#if，#else， #endif之间跳跃。</span><br></pre></td></tr></table></figure><p>下面的括号匹配对编程很实用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ci&#39;, di&#39;, yi&#39;：修改、剪切或复制&#39;之间的内容。</span><br><span class="line">ca&#39;, da&#39;, ya&#39;：修改、剪切或复制&#39;之间的内容，包含&#39;。</span><br><span class="line">ci&quot;, di&quot;, yi&quot;：修改、剪切或复制&quot;之间的内容。</span><br><span class="line">ca&quot;, da&quot;, ya&quot;：修改、剪切或复制&quot;之间的内容，包含&quot;。</span><br><span class="line">ci(, di(, yi(：修改、剪切或复制()之间的内容。</span><br><span class="line">ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</span><br><span class="line">ci[, di[, yi[：修改、剪切或复制[]之间的内容。</span><br><span class="line">ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</span><br><span class="line">ci&#123;, di&#123;, yi&#123;：修改、剪切或复制&#123;&#125;之间的内容。</span><br><span class="line">ca&#123;, da&#123;, ya&#123;：修改、剪切或复制&#123;&#125;之间的内容，包含&#123;&#125;。</span><br><span class="line">ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</span><br><span class="line">ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</span><br></pre></td></tr></table></figure><h4 id="13-2-ctags"><a href="#13-2-ctags" class="headerlink" title="13.2 ctags"></a>13.2 ctags</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</span><br><span class="line">:set tags&#x3D;path&#x2F;tags -- 告诉ctags使用哪个tag文件</span><br><span class="line">:tag xyz -- 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</span><br><span class="line">:stag xyz -- 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</span><br><span class="line">:ptag xyz -- 在预览窗口中打开xyz的定义，热键是C-w &#125;。</span><br><span class="line">:pclose -- 关闭预览窗口。热键是C-w z。</span><br><span class="line">:pedit abc.h -- 在预览窗口中编辑abc.h</span><br><span class="line">:psearch abc -- 搜索当前文件和当前文件include的文件，显示包含abc的行。</span><br></pre></td></tr></table></figure><p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:[n]tnext -- 下一[n]个匹配。</span><br><span class="line">:[n]tprev -- 上一[n]个匹配。</span><br><span class="line">:tfirst -- 第一个匹配</span><br><span class="line">:tlast -- 最后一个匹配</span><br><span class="line">:tselect tagname -- 打开选择列表</span><br></pre></td></tr></table></figure><p>tab键补齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:tag xyz&lt;tab&gt; -- 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</span><br><span class="line">:tag &#x2F;xyz&lt;tab&gt; -- 会用名字中含有xyz的tag名补全。</span><br></pre></td></tr></table></figure><h4 id="13-3-cscope"><a href="#13-3-cscope" class="headerlink" title="13.3 cscope"></a>13.3 cscope</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cscope -Rbq: 生成cscope.out文件</span><br><span class="line">:cs add &#x2F;path&#x2F;to&#x2F;cscope.out &#x2F;your&#x2F;work&#x2F;dir</span><br><span class="line">:cs find c func -- 查找func在哪些地方被调用</span><br><span class="line">:cw -- 打开quickfix窗口查看结果</span><br></pre></td></tr></table></figure><h4 id="13-4-gtags"><a href="#13-4-gtags" class="headerlink" title="13.4 gtags"></a>13.4 gtags</h4><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:Gtags funcname 定位到 funcname 的定义处。</span><br><span class="line">:Gtags -r funcname 查询 funcname被引用的地方。</span><br><span class="line">:Gtags -s symbol 定位 symbol 出现的地方。</span><br><span class="line">:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</span><br><span class="line">:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</span><br><span class="line">:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P &#x2F;vm&#x2F; 显示vm目录下的文件。</span><br></pre></td></tr></table></figure><h4 id="13-5-编译"><a href="#13-5-编译" class="headerlink" title="13.5 编译"></a>13.5 编译</h4><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p><p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.java文件，你可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg&#x3D;javac\ abc.java</span><br></pre></td></tr></table></figure><p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm&#x3D;%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure><p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p><h4 id="13-6-快速修改窗口"><a href="#13-6-快速修改窗口" class="headerlink" title="13.6 快速修改窗口"></a>13.6 快速修改窗口</h4><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:copen -- 打开快速修改窗口。</span><br><span class="line">:cclose -- 关闭快速修改窗口。</span><br></pre></td></tr></table></figure><p>快速修改窗口在make程序时非常有用，当make之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:cl -- 在快速修改窗口中列出错误。</span><br><span class="line">:cn -- 定位到下一个错误。</span><br><span class="line">:cp -- 定位到上一个错误。</span><br><span class="line">:cr -- 定位到第一个错误。</span><br><span class="line">13.7 自动补全</span><br><span class="line">C-x C-s -- 拼写建议。</span><br><span class="line">C-x C-v -- 补全vim选项和命令。</span><br><span class="line">C-x C-l -- 整行补全。</span><br><span class="line">C-x C-f -- 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</span><br><span class="line">C-x C-p 和C-x C-n -- 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</span><br><span class="line">C-x C-o -- 编程时可以补全关键字和函数名啊。</span><br><span class="line">C-x C-i -- 根据头文件内关键字补全。</span><br><span class="line">C-x C-d -- 补全宏定义。</span><br><span class="line">C-x C-n -- 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</span><br></pre></td></tr></table></figure><p>当弹出补全菜单后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C-p 向前切换成员；</span><br><span class="line">C-n 向后切换成员；</span><br><span class="line">C-e 退出下拉菜单，并退回到原来录入的文字；</span><br><span class="line">C-y 退出下拉菜单，并接受当前选项。</span><br><span class="line">13.8 多行缩进缩出</span><br><span class="line">正常模式下，按两下&gt;;光标所在行会缩进。</span><br><span class="line">如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</span><br><span class="line">对应的，按两下&lt;;，光标所在行会缩出。</span><br><span class="line">如果在编辑代码文件，可以用&#x3D;进行调整。</span><br><span class="line">在可视模式下，选择要调整的代码块，按&#x3D;，代码会按书写规则缩排好。</span><br><span class="line">或者n &#x3D;，调整n行代码的缩排。</span><br></pre></td></tr></table></figure><h4 id="13-9-折叠"><a href="#13-9-折叠" class="headerlink" title="13.9 折叠"></a>13.9 折叠</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zf -- 创建折叠的命令，可以在一个可视区域上使用该命令；</span><br><span class="line">zd -- 删除当前行的折叠；</span><br><span class="line">zD -- 删除当前行的折叠；</span><br><span class="line">zfap -- 折叠光标所在的段；</span><br><span class="line">zo -- 打开折叠的文本；</span><br><span class="line">zc -- 收起折叠；</span><br><span class="line">za -- 打开&#x2F;关闭当前折叠；</span><br><span class="line">zr -- 打开嵌套的折行；</span><br><span class="line">zm -- 收起嵌套的折行；</span><br><span class="line">zR (zO) -- 打开所有折行；</span><br><span class="line">zM (zC) -- 收起所有折行；</span><br><span class="line">zj -- 跳到下一个折叠处；</span><br><span class="line">zk -- 跳到上一个折叠处；</span><br><span class="line">zi -- enable&#x2F;disable fold;</span><br></pre></td></tr></table></figure><h3 id="14-命令行"><a href="#14-命令行" class="headerlink" title="14. 命令行"></a>14. 命令行</h3><p>normal模式下按:进入命令行模式</p><h4 id="14-1-命令行模式下的快捷键："><a href="#14-1-命令行模式下的快捷键：" class="headerlink" title="14.1 命令行模式下的快捷键："></a>14.1 命令行模式下的快捷键：</h4><p>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。<br>左右方向键：左/右移一个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C-w： 向前删除一个单词。</span><br><span class="line">C-h： 向前删除一个字符，等同于Backspace。</span><br><span class="line">C-u： 从当前位置移动到命令行开头。</span><br><span class="line">C-b： 移动到命令行开头。</span><br><span class="line">C-e： 移动到命令行末尾。</span><br><span class="line">Shift-Left： 左移一个单词。</span><br><span class="line">Shift-Right： 右移一个单词。</span><br><span class="line">@： 重复上一次的冒号命令。</span><br><span class="line">q： 正常模式下，q然后按&#39;:&#39;，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</span><br><span class="line">q&#x2F;和q? 可以打开查找历史记录。</span><br></pre></td></tr></table></figure><h4 id="14-2-执行外部命令"><a href="#14-2-执行外部命令" class="headerlink" title="14.2 执行外部命令"></a>14.2 执行外部命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:! cmd 执行外部命令。</span><br><span class="line">:!! 执行上一次的外部命令。</span><br><span class="line">:sh 调用shell，用exit返回vim。</span><br><span class="line">:r !cmd 将命令的返回结果插入文件当前位置。</span><br><span class="line">:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</span><br></pre></td></tr></table></figure><h3 id="15-其它"><a href="#15-其它" class="headerlink" title="15. 其它"></a>15. 其它</h3><h4 id="15-1-工作目录"><a href="#15-1-工作目录" class="headerlink" title="15.1 工作目录"></a>15.1 工作目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:pwd 显示vim的工作目录。</span><br><span class="line">:cd path 改变vim的工作目录。</span><br><span class="line">:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</span><br></pre></td></tr></table></figure><h4 id="15-2-一些快捷键（收集中）"><a href="#15-2-一些快捷键（收集中）" class="headerlink" title="15.2 一些快捷键（收集中）"></a>15.2 一些快捷键（收集中）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">K: 打开光标所在词的manpage。</span><br><span class="line">*: 向下搜索光标所在词。</span><br><span class="line">g*: 同上，但部分符合即可。</span><br><span class="line">#: 向上搜索光标所在词。</span><br><span class="line">g#: 同上，但部分符合即可。</span><br><span class="line">g C-g: 统计全文或统计部分的字数。</span><br></pre></td></tr></table></figure><h4 id="15-3-在线帮助"><a href="#15-3-在线帮助" class="headerlink" title="15.3 在线帮助"></a>15.3 在线帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:h(elp)或F1 打开总的帮助。</span><br><span class="line">:help user-manual 打开用户手册。</span><br><span class="line">命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</span><br><span class="line">:helptags somepath 为somepath中的文档生成索引。</span><br><span class="line">:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</span><br><span class="line">Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</span><br><span class="line">:ver 显示版本信息。</span><br></pre></td></tr></table></figure><h4 id="15-4-一些小功能"><a href="#15-4-一些小功能" class="headerlink" title="15.4 一些小功能"></a>15.4 一些小功能</h4><p>简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在windows终端里面使用tree命令</title>
      <link href="/2018/05/13/tree-win/"/>
      <url>/2018/05/13/tree-win/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;有时候我们需要为我们的项目生成一个树状结构图，windows提供了一个<code>tree</code>命令可供我们使用，但是windows提供的<code>tree</code>命令太过于鸡肋，让我们是又爱又恨，只提供了两个参数供我们使用，不像Linux系统提供的<code>tree</code>命令那么功能强大，深受大家的喜爱，那么对于Windows系统，我们是不是可以放弃了，这里我给大家提供几个方法，方便在Windows系统下面使用这个功能。</p><span id="more"></span><h3 id="Windows下面原生的tree的使用"><a href="#Windows下面原生的tree的使用" class="headerlink" title="Windows下面原生的tree的使用"></a>Windows下面原生的<code>tree</code>的使用</h3><h4 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F:\website</span><br><span class="line">λ tree</span><br><span class="line">卷 新加卷 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 EC5C-5B89</span><br><span class="line">F:.</span><br><span class="line">├─css</span><br><span class="line">└─lib</span><br></pre></td></tr></table></figure><p>这里可以看到输出了website文件下面的两个目录的名字，对于文件夹下面的文件以及子目录里面的文件并没有输出，显然这不是我们想要的，那么我们使用帮助命令看一下，是否有其它参数可供我们选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\website</span><br><span class="line">λ tree &#x2F;?</span><br><span class="line">以图形显示驱动器或路径的文件夹结构。</span><br><span class="line"></span><br><span class="line">TREE [drive:][path] [&#x2F;F] [&#x2F;A]</span><br><span class="line"></span><br><span class="line">   &#x2F;F   显示每个文件夹中文件的名称。</span><br><span class="line">   &#x2F;A   使用 ASCII 字符，而不使用扩展字符。</span><br></pre></td></tr></table></figure><h4 id="获取全部目录及文件"><a href="#获取全部目录及文件" class="headerlink" title="获取全部目录及文件"></a>获取全部目录及文件</h4><p>在上面的命令中我们看到第一条命令可以显示文件夹中文件的名称，似乎可以达到我们的要求，下面我们试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">F:\website</span><br><span class="line">λ tree &#x2F;F</span><br><span class="line">卷 新加卷 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 EC5C-5B89</span><br><span class="line">F:.</span><br><span class="line">│  index.html</span><br><span class="line">│</span><br><span class="line">├─css</span><br><span class="line">│      banner.css</span><br><span class="line">│      main.css</span><br><span class="line">│</span><br><span class="line">└─lib</span><br><span class="line">        banner.js</span><br><span class="line">        jquery.js</span><br></pre></td></tr></table></figure><p>可以看到确实按照我们想要的结构输出了，但是只有两个命令的使用并不能满足我们日常的需要，比如我们想忽略某个文件，想把生成的树状结构输出的一个文件中又该如何操作，请接着往下看</p><h3 id="使用基于node的tree-cli或者treer两个包"><a href="#使用基于node的tree-cli或者treer两个包" class="headerlink" title="使用基于node的tree-cli或者treer两个包"></a>使用基于<code>node</code>的<code>tree-cli</code>或者<code>treer</code>两个包</h3><p>要想使用这些命令，我们需要做一些准备</p><ul><li><p>nodejs安装，可以戳<a href="https://nodejs.org/en/download/">这里</a>(建议使用LTS的稳定版本，另nodejs自带了npm安装包管理器)</p></li><li><p>cmder，一个替代windows的强大命令终端，安装及使用教程可以戳<a href="https://www.jianshu.com/p/b691b48bcee3">这里</a></p></li></ul><h4 id="tree-cli的使用"><a href="#tree-cli的使用" class="headerlink" title="tree-cli的使用"></a>tree-cli的使用</h4><p>1、首先安装此模块包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tree-cli</span><br></pre></td></tr></table></figure><p>2、使用此命令</p><p>我们先开启<code>cmder</code>，并开启一个<code>bash</code>窗口来操作(cmder默认是cmd视窗，可以根据自己需要来设置默认视窗)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">λ tree --help                                                                        </span><br><span class="line">                                                                                     </span><br><span class="line">  List contents of directories in tree-like format.                                  </span><br><span class="line">                                                                                     </span><br><span class="line">  tree - list contents of directories in tree-like format                            </span><br><span class="line">                                                                                     </span><br><span class="line">  Tree is a recursive directory listing program that                                 </span><br><span class="line">  produces a depth indented listing of files.                                        </span><br><span class="line">  With no arguments, tree lists the files in the                                     </span><br><span class="line">  current directory. When directory arguments are                                    </span><br><span class="line">  given, tree lists all the files and&#x2F;or directories                                 </span><br><span class="line">  found in the given directories each in turn. Upon                                  </span><br><span class="line">  completion of listing all files&#x2F;directories found,                                 </span><br><span class="line">  tree returns the total number of files and&#x2F;or                                      </span><br><span class="line">  directories listed.                                                                </span><br><span class="line">                                                                                     </span><br><span class="line">  USAGE                                                                              </span><br><span class="line">                                                                                     </span><br><span class="line">    tree &lt;options&gt;                                                                   </span><br><span class="line">                                                                                     </span><br><span class="line">  OPTIONS:                                                                           </span><br><span class="line">                                                                                     </span><br><span class="line">  --help   outputs a verbose usage listing.                                                 </span><br><span class="line">  --version   outputs the version of tree-cli.                                                 </span><br><span class="line">  --debug   show debug info.                                                                 </span><br><span class="line">  --ignore  ignores directory or file you specify.                                           </span><br><span class="line">  --fullpath    prints the full path prefix for each file.                                       </span><br><span class="line">  --noreport    omits printing of the file and directory report at the  end of the tree listing and omits printing the tree on console.                                                                         </span><br><span class="line">  -a    all files are printed. By default tree does not print hidden files (those beginning with a dot &#39;.&#39;). In no     event does tree print the file system constructs &#39;.&#39;   (current directory) and &#39;..&#39; (previous directory). </span><br><span class="line">  -d    list directories only.                                                           </span><br><span class="line">  -f    append a &#39;&#x2F;&#39; for directories, a &#39;&#x3D;&#39; for socket files  and a &#39;|&#39; for FIFOs                                                              </span><br><span class="line">  -i    makes tree not print the indentation lines, useful when used in conjunction with the -f option.                                     </span><br><span class="line">  -l    max display depth of the directory tree.                                         </span><br><span class="line">  -o    send output to filename.                                                         </span><br><span class="line">                                                                                     </span><br><span class="line">  EXAMPLE:                                                                           </span><br><span class="line">                                                                                     </span><br><span class="line">  $ tree                                                                             </span><br><span class="line">                                                                                     </span><br><span class="line">  $ tree -l 2, -o out.txt --ignore [node_modules, test] -d --noreport                </span><br></pre></td></tr></table></figure><p>可以看到<code>tree-cli</code>为我们提供了很多参数命令供我们使用，现在我们来使用一下，我们在根目录创建<code>README.md</code>文件，并使用<code>tree</code>命令生成树状结构图并输出到此文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ tree -l 3, -o README.md  --ignore &#39;README.md&#39; --noreport</span><br><span class="line">▁ Finish writing to file: F:\website\README.md</span><br></pre></td></tr></table></figure><p>上面我们使用了命令显示3级的深度，并忽略掉<code>README.md</code>文件本身，并省略列表末尾的目录报告，现在我们打开文件看一下(这里我们使用了参数<code>-l</code>，是因为该<code>tree</code>命令默认只显示深度层级为一级)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\website</span><br><span class="line">├── css</span><br><span class="line">|  ├── banner.css</span><br><span class="line">|  └── main.css</span><br><span class="line">├── index.html</span><br><span class="line">├── lib</span><br><span class="line">|  ├── banner.js</span><br><span class="line">|  └── jquery.js</span><br></pre></td></tr></table></figure><p>可以看到命令执行成功，其它命令不在逐一演示，这些命令可以完成我们日常的大部分需求了</p><h4 id="tree-node-cli"><a href="#tree-node-cli" class="headerlink" title="tree-node-cli"></a>tree-node-cli</h4><p>1、首先安装此模块包</p><p>PS：如果之前安装了<code>tree-cli</code>,需要先卸载，防止命令使用上的冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#卸载之前安装的模块包</span><br><span class="line">npm uninstall -g tree-cli</span><br><span class="line">#安装tree-node-cli模块包</span><br><span class="line">npm install -g tree-node-cli</span><br></pre></td></tr></table></figure><p>2、使用此命令</p><p>依然是先查看该命令提供的一些参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">λ tree --help</span><br><span class="line"></span><br><span class="line">  Usage: tree [options]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -V, --version             output the version number</span><br><span class="line">    -a, --all-files           All files, include hidden files, are printed.</span><br><span class="line">    --dirs-first              List directories before files.</span><br><span class="line">    -d, --dirs-only           List directories only.</span><br><span class="line">    -I, --exclude [patterns]  Exclude files that match the pattern. | separates alternate patterns. Wrap your entire pattern in double quotes. E.g. &#96;&quot;node_modules|lcov&quot;.</span><br><span class="line">    -L, --max-depth &lt;n&gt;       Max display depth of the directory tree.</span><br><span class="line">    -r, --reverse             Sort the output in reverse alphabetic order.</span><br><span class="line">    -F, --trailing-slash      Append a &#39;&#x2F;&#39; for directories.</span><br><span class="line">    -h, --help                output usage information</span><br></pre></td></tr></table></figure><p>可以看到提供的一些参数跟在linux系统里面使用<code>tree</code>命令提供的参数较为一致(linux系统的使用用户应该比较喜欢这个)，只是命令少了一点，目前此模块作者还在持续更新，期待更多的功能开放出来</p><p>下面我们使用命令来操作一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">λ tree</span><br><span class="line">website</span><br><span class="line">├── css</span><br><span class="line">│   ├── banner.css</span><br><span class="line">│   └── main.css</span><br><span class="line">├── index.html</span><br><span class="line">├── lib</span><br><span class="line">│   ├── banner.js</span><br><span class="line">│   └── jquery.js</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>可以看到此命令默认显示所有层级，如果你的目录层级结构较深并且文件较多，可能会造成时间读取较长或者命令终端假死，所有请大家在使用之前先看下该命令所提供的一些参数，灵活使用命令进行目录结构输出</p><h3 id="Tree-for-Windows工具"><a href="#Tree-for-Windows工具" class="headerlink" title="Tree for Windows工具"></a>Tree for Windows工具</h3><p>这是<a href="http://gnuwin32.sourceforge.net/">GnuWin32</a>提供的一套工具，该工具提供了一套强大的<code>tree</code>命令以供在windows下面使用，使用Windows自带终端即可，目前该工具以停止维护多年，使用上请慎重。</p><p>以上，就是安利给大家在Windows上怎么使用<code>tree</code>命令来生成树状结构图，以完成我们在日常工作中的需要，如有不对的地方，望指出修正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用NVM来管理nodejs</title>
      <link href="/2018/05/09/nvm-use/"/>
      <url>/2018/05/09/nvm-use/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我们知道nodejs官方更新的速度非常快，而我们的业务里使用的一般是某一个版本，当有新的项目进来，使用的技术栈中nodejs版本高于当前电脑安装版本，就会导致项目运行出错，因此nvm的出现，可以使我们更专注于业务的操作，把nodejs的版本控制交由nvm来处理，本文分别介绍一下在Windows和mac下面安装和使用过程。</p><span id="more"></span><h3 id="windows下安装和使用nvm"><a href="#windows下安装和使用nvm" class="headerlink" title="windows下安装和使用nvm"></a>windows下安装和使用nvm</h3><h4 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h4><ul><li>检查本地是否安装nodejs</li></ul><p>在进行安装之前，需要检查一下本地是否安装了nodejs，如果之前有安装过，需要卸载和删除nodejs以及npm的安装目录</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>nvm-windows 最新下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>打开链接，可以看到有两个版本【Pre-release 1.1.6】和 【Latest release 1.1.5]，我们下载当前稳定版本1.1.5就可以了。1.1.6版本是最新版本，可能还不是很稳定。</p><p>而这里又有四个可下载的文件：</p><ul><li>nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置</li><li>nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。</li><li>Source code(zip)：zip压缩的源码</li><li>Sourc code(tar.gz)：tar.gz的源码，一般用于linux系统<br>笔者这里使用的是第二种</li></ul><p>解压下载好的安装包，双击执行下载的setup文件开始安装，一路默认即可，安装完成之后，新开命令窗口输入<code>nvm</code>，如果出现一下提示，说明安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> Running version 1.1.5. </span><br><span class="line"> </span><br><span class="line">Usage:</span><br><span class="line">  nvm arch                     : Show if node is running in 32 or 64 bit mode.</span><br><span class="line">  nvm install &lt;version&gt; [arch] : The version can be a node.js version or &quot;latest&quot; for the latest stable version.</span><br><span class="line">                                 Optionally specify whether to install the 32 or 64 bit version (defaults to system arch).</span><br><span class="line">                                 Set [arch] to &quot;all&quot; to install 32 AND 64 bit versions.</span><br><span class="line">                                 Add --insecure to the end of this command to bypass SSL validation of the remote download server.</span><br><span class="line">  nvm list [available]         : List the node.js installations. Type &quot;available&quot; at the end to see what can be installed. Aliased as ls.</span><br><span class="line">  nvm on                       : Enable node.js version management.</span><br><span class="line">  nvm off                      : Disable node.js version management.</span><br><span class="line">  nvm proxy [url]              : Set a proxy to use for downloads. Leave [url] blank to see the current proxy.</span><br><span class="line">                                 Set [url] to &quot;none&quot; to remove the proxy.</span><br><span class="line">  nvm node_mirror [url]        : Set the node mirror. Defaults to https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;. Leave [url] blank to use default url.</span><br><span class="line">  nvm npm_mirror [url]         : Set the npm mirror. Defaults to https:&#x2F;&#x2F;github.com&#x2F;npm&#x2F;npm&#x2F;archive&#x2F;. Leave [url] blank to default url.</span><br><span class="line">  nvm uninstall &lt;version&gt;      : The version must be a specific version.</span><br><span class="line">  nvm use [version] [arch]     : Switch to use the specified version. Optionally specify 32&#x2F;64bit architecture.</span><br><span class="line">                                 nvm use &lt;arch&gt; will continue using the selected version, but switch to 32&#x2F;64 bit mode.</span><br><span class="line">  nvm root [path]              : Set the directory where nvm should store different versions of node.js.</span><br><span class="line">                                 If &lt;path&gt; is not set, the current root will be displayed.</span><br><span class="line">  nvm version                  : Displays the current running version of nvm for Windows. Aliased as v.</span><br></pre></td></tr></table></figure><h3 id="mac下安装和使用nvm"><a href="#mac下安装和使用nvm" class="headerlink" title="mac下安装和使用nvm"></a>mac下安装和使用nvm</h3><h4 id="安装之前的准备"><a href="#安装之前的准备" class="headerlink" title="安装之前的准备"></a>安装之前的准备</h4><ul><li>查看电脑上是否有全局安装的node/npm</li></ul><p>如果之前是在官网下载的 node 安装包，运行后会自动安装在全局目录，其中 node 命令在 /usr/local/bin/node，npm 命令在全局 node_modules 目录中，具体路径为 /usr/local/lib/node_modules/npm</p><ul><li>安装 nvm 之前最好先删除下已安装的 node 和全局 node 模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm ls -g --depth&#x3D;0 # 查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装</span><br><span class="line">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules # 删除全局 node_modules 目录</span><br><span class="line">sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node # 删除 node</span><br><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;bin &amp;&amp; ls -l | grep &quot;..&#x2F;lib&#x2F;node_modules&#x2F;&quot; | awk &#39;&#123;print $9&#125;&#39;| xargs rm # 删除全局 node 模块注册的软链</span><br></pre></td></tr></table></figure><h4 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.8&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure><p>详见<a href="https://github.com/creationix/nvm">：https://github.com/creationix/nvm</a></p><p>安装完 nvm 后，输入nvm，会看到有输出,则 nvm 安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; Compressing and cleaning up git repository</span><br><span class="line"></span><br><span class="line">&#x3D;&gt; Profile not found. Tried ~&#x2F;.bashrc, ~&#x2F;.bash_profile, ~&#x2F;.zshrc, and ~&#x2F;.profile.</span><br><span class="line">&#x3D;&gt; Create one of them and run this script again</span><br><span class="line">   OR</span><br><span class="line">&#x3D;&gt; Append the following lines to the correct file yourself:</span><br><span class="line"></span><br><span class="line">export NVM_DIR&#x3D;&quot;$HOME&#x2F;.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR&#x2F;nvm.sh&quot;  # This loads nvm</span><br><span class="line">&#x3D;&gt; Close and reopen your terminal to start using nvm or run the following to use it now:</span><br><span class="line"></span><br><span class="line">export NVM_DIR&#x3D;&quot;$HOME&#x2F;.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR&#x2F;nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure><p> 如果遇到关闭shell后遇到以下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: nvm: command not found</span><br></pre></td></tr></table></figure><p>编辑.bash_profile文件，没有的话就新建一个，命令都是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi .bash_profile</span><br></pre></td></tr></table></figure><p>然后复制安装nvm成功时候出现的提示,保存退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR&#x3D;&quot;$HOME&#x2F;.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR&#x2F;nvm.sh&quot;</span><br></pre></td></tr></table></figure><p>然后 source 一下 .bash_profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><h3 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h3><p><code>nvm install &lt;version&gt;</code>  ## 安装指定版本，可模糊安装，如：安装v8.10.0，既可nvm install v8.10.0</p><p><code>nvm uninstall &lt;version&gt;</code>  ## 删除已安装的指定版本，语法与install类似</p><p><code>nvm use &lt;version&gt;</code>  ## 切换使用指定的版本node</p><p><code>nvm ls</code>  ## 列出所有安装的版本</p><p><code>nvm ls-remote</code>  ## 列出所以远程服务器的版本（windows下面命令是<code>nvm list available</code>）</p><p><code>nvm current</code>  ## 显示当前的版本</p><p><code>nvm alias default &lt;version&gt;</code>  ## 指定默认使用版本，不用每次新开命令行都要使用<code>nvm use</code>来指定版本了</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之ajax 二进制文件下载</title>
      <link href="/2018/05/08/downloadfile-ajax/"/>
      <url>/2018/05/08/downloadfile-ajax/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;随着前后端分离的势头越来越火热，各大公司都纷纷进行前后端分离模式的工作模式调整，同时业务处理中也会有不同的问题浮现出来，那么对于使用ajax进行二进制文件下载就是其中的一个问题，本文我们探究一下此问题解决方案.</p><span id="more"></span><h3 id="处理方案：XHR2"><a href="#处理方案：XHR2" class="headerlink" title="处理方案：XHR2"></a>处理方案：XHR2</h3><p>XMLHttpRequest Level 2作为新的浏览器API，同时也增加了responseType和response两个新的属性，通过这两个属性来告知浏览器把请求到的数据按照某种格式进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.responseType</span><br><span class="line">&#x2F;&#x2F;在发送请求之前，根据需求把xhr.responseType设置&#39;text&#39;、&#39;arraybuffer&#39;、&#39;blob&#39;或者&#39;document&#39;。它的默认值是&#39;text&#39; 。</span><br><span class="line">xhr.response</span><br><span class="line">&#x2F;&#x2F;获得了数据之后，根据之前responseType的值，xhr的response属性就是DOMString、ArrayBuffer、Blob或者Document格式的数据</span><br></pre></td></tr></table></figure><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//step1:创建xmlhttprequest</span></span><br><span class="line"><span class="keyword">var</span> oAjax = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  oAjax = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//step2:连接服务器</span></span><br><span class="line">oAjax.open(<span class="string">&#x27;post&#x27;</span>, url, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">//step3:设置请求header，可根据实际场景按需设置</span></span><br><span class="line">oAjax.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">//step4:设置数据请求格式</span></span><br><span class="line">oAjax.responseType = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line"><span class="comment">//step5:接收服务器的返回</span></span><br><span class="line">oAjax.send(<span class="built_in">JSON</span>.stringify(data)); </span><br><span class="line">oAjax.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="comment">//处理下载逻辑，下面详解</span></span><br><span class="line">     <span class="comment">//第三个参数为处理文件类型</span></span><br><span class="line">     downfile(<span class="built_in">this</span>.response,<span class="string">&#x27;文件名称&#x27;</span>,&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、使用插件FileSaver.js处理下载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/eligrey/FileSaver.js/</span></span><br><span class="line"><span class="keyword">var</span> FileSaver = <span class="built_in">require</span>(<span class="string">&#x27;file-saver&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downfile</span>(<span class="params">filestream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="keyword">new</span> File([filestream],filename, &#123;<span class="attr">type</span>: <span class="string">&quot;application/excel; charset=UTF-8&quot;</span>&#125;);   </span><br><span class="line">    <span class="keyword">if</span>(file.size &amp;&amp; file.size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        FileSaver.saveAs(file);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//给出不能下载提示</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的type类型和文件名称也可以通过服务端的返回头responseheader处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filename = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> disposition = xhr.getResponseHeader(<span class="string">&#x27;Content-Disposition&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (disposition &amp;&amp; disposition.indexOf(<span class="string">&#x27;attachment&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> filenameRegex = <span class="regexp">/filename[^;=]*=(([&#x27;&quot;]).*?2|[^;]*)/</span>;</span><br><span class="line">    <span class="keyword">var</span> matches = filenameRegex.exec(disposition);</span><br><span class="line">    <span class="keyword">if</span> (matches != <span class="literal">null</span> &amp;&amp; matches[<span class="number">1</span>]) filename = matches[<span class="number">1</span>].replace(<span class="regexp">/[&#x27;&quot;]/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> type = xhr.getResponseHeader(<span class="string">&#x27;Content-Type&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> File([filestream],filename, type);      </span><br><span class="line">FileSaver.saveAs(file);</span><br></pre></td></tr></table></figure><p>2、使用超链接，借助download属性处理下载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downfile</span>(<span class="params">filestream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([filestream], &#123;<span class="attr">type</span>: <span class="string">&quot;application/excel; charset=UTF-8&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line">    <span class="keyword">var</span> downloadUrl = URL.createObjectURL(blob);</span><br><span class="line">    <span class="built_in">window</span>.location = downloadUrl</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a.download === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location = downloadUrl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a.href = downloadUrl;</span><br><span class="line">        a.id = <span class="string">&#x27;downloadfile&#x27;</span></span><br><span class="line">        a.download = <span class="string">&#x27;AA.xls&#x27;</span>;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">        a.click();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; removeNode(<span class="literal">null</span>,<span class="string">&#x27;downloadfile&#x27;</span>); URL.revokeObjectURL(downloadUrl); &#125;, <span class="number">1000</span>); <span class="comment">// 释放资源</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">pid,cid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(pid) || <span class="built_in">document</span>.body;</span><br><span class="line">    <span class="keyword">var</span> myNode = <span class="built_in">document</span>.getElementById(cid);</span><br><span class="line">    container.removeChild(myNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是处理二进制文件下载的方案，希望可以帮助到您！</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件下载 </tag>
            
            <tag> ajax </tag>
            
            <tag> download </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用javascript实现Date对象的继承</title>
      <link href="/2018/05/07/date-extend/"/>
      <url>/2018/05/07/date-extend/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;最近在处理时间的时候发现一个问题，不能继承<code>Date</code>上面的方法，之前使用其它的对象都没出现过问题，我们先看下面这个例子，使用经典的寄生组合继承</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 经典的js寄生组合式继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Date</span>.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">this</span>.abc = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Inner.prototype = superClass.prototype;</span><br><span class="line">    subClass.prototype = <span class="keyword">new</span> Inner();</span><br><span class="line">    subClass.prototype.constructor = subClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(MyDate, <span class="built_in">Date</span>);</span><br><span class="line"></span><br><span class="line">MyDate.prototype.getTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getTime();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> MyDate();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(date.getTest());</span><br></pre></td></tr></table></figure><p>运行之后，可以在控制台里面看到如下输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VM2356:<span class="number">17</span> Uncaught <span class="built_in">TypeError</span>: <span class="built_in">this</span> is not a <span class="built_in">Date</span> object.</span><br><span class="line">    at MyDate.getTime (&lt;anonymous&gt;)</span><br><span class="line">    at MyDate.getTest (&lt;anonymous&gt;:<span class="number">17</span>:<span class="number">17</span>)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">23</span>:18us&gt;:<span class="number">20</span>:<span class="number">17</span>)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">26</span>:<span class="number">18</span></span><br></pre></td></tr></table></figure><p>这是什么原因呢，MDN中有提到，JavaScript的日期对象只能通过<code>JavaScript Date</code>作为构造函数来实例化，那么，是不是就无法使用Date来实现继承来呢？</p><p>通过在网上查找，发现了网友给出的很多有趣的答案，现将网上的答案整理如下，不外乎有三种：</p><ul><li>1、比较暴力的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">that</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">        <span class="keyword">var</span> methods = [<span class="string">&#x27;getDate&#x27;</span>,<span class="string">&#x27;getTime&#x27;</span>,<span class="string">&#x27;getYear&#x27;</span>,<span class="comment">/***/</span>,<span class="string">&#x27;toString&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            that[methods[i]] = d[methods[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.MyTest() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;dd&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法使用了方法代理，并不能称之为继承</p><ul><li>2、使用es5来实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要考虑polyfill情况</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ||</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">    obj.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用了点技巧的继承，实际上返回的是Date对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// bind属于Function.prototype，接收的参数是：object, param1, params2...</span></span><br><span class="line">    <span class="keyword">var</span> dateInst = <span class="keyword">new</span>(<span class="built_in">Function</span>.prototype.bind.apply(<span class="built_in">Date</span>, [<span class="built_in">Date</span>].concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))))();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改原型指向，否则无法调用MyDate原型上的方法</span></span><br><span class="line">    <span class="comment">// ES6方案中，这里就是[[prototype]]这个隐式原型对象，在没有标准以前就是__proto__</span></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(dateInst, MyDate.prototype);</span><br><span class="line"></span><br><span class="line">    dateInst.abc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dateInst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型重新指回Date，否则根本无法算是继承</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(MyDate.prototype, <span class="built_in">Date</span>.prototype);</span><br><span class="line"></span><br><span class="line">MyDate.prototype.getTest = <span class="function"><span class="keyword">function</span> <span class="title">getTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getTime();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> MyDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常输出，譬如1525744465718</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getTest());</span><br></pre></td></tr></table></figure><p>可以看到，用的是非常巧妙的一种做法：</p><p>正常继承的情况如下：</p><p><code>new MyDate()</code>返回实例对象<code>date</code>是由<code>MyDate</code>构造的<br>原型链回溯是: <code>date(MyDate对象)-&gt;date.__proto__-&gt;MyDate.prototype-&gt;MyDate.prototype.__proto__-&gt;Date.prototype</code></p><p>这种做法的继承的情况如下：</p><p><code>new MyDate()</code>返回实例对象date是由Date构造的<br>原型链回溯是: <code>date(Date对象)-&gt;date.__proto__-&gt;MyDate.prototype-&gt;MyDate.prototype.__proto__-&gt;Date.prototype</code></p><p>可以看出，关键点在于：</p><p>构造函数里返回了一个真正的<code>Date</code>对象（由<code>Date</code>构造，所以有这些内部类中的关键<code>[[Class]]</code>标志），所以它有调用<code>Date</code>原型上方法的权利</p><p>构造函数里的<code>Date</code>对象的<code>[[ptototype]]</code>（对外，浏览器中可通过<code>__proto__</code>访问）指向<code>MyDate.prototype</code>，然后<code>MyDate.prototype</code>再指向<code>Date.prototype</code>。</p><p>所以最终的实例对象仍然能进行正常的原型链回溯，回溯到原本Date的所有原型方法</p><ul><li>3、使用ES6的class来实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.abc = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> MyDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常输出，譬如1515638988725</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getTest());</span><br></pre></td></tr></table></figure><p>这里的正常输出环境是直接用ES6运行，不经过babel打包，打包后实质上是转化成ES5的，所以效果完全不一样</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> date </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
